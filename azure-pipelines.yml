trigger:
- main
- feature/*

pool:
  name: 'LocalAgent'

variables:
  buildConfiguration: 'Release'
  artifactName: 'HelloWorldApp'
  isMaster: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  isFeature: $[startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')]

steps:
- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- script: |
    if [ -f version.txt ]; then
      VERSION=$(cat version.txt)
    else
      VERSION="1.0.0"
    fi
    IFS='.' read -r major minor patch <<< "$VERSION"
    patch=$((patch + 1))
    NEW_VERSION="$major.$minor.$patch"
    echo $NEW_VERSION > version.txt
    echo "##vso[task.setvariable variable=buildVersion]$NEW_VERSION"
    echo "Current Version: $VERSION"
    echo "New Version: $NEW_VERSION"
  displayName: 'Increment and print version'

# SonarCloud - ONLY on feature branches (using newer version)
- task: SonarCloudPrepare@4
  condition: eq(variables.isFeature, true)
  displayName: 'Prepare SonarCloud analysis'
  inputs:
    SonarCloud: 'SonarCloudConnection'
    organization: '1bar1'
    scannerMode: 'dotnet'
    projectKey: '1bar1_HelloWorldPipeline'
    projectName: 'HelloWorldPipeline'

- task: DotNetCoreCLI@2
  displayName: 'Build project'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) /p:Version=$(buildVersion)'

# SonarCloud analyze - ONLY on feature branches
- task: SonarCloudAnalyze@4
  condition: eq(variables.isFeature, true)
  displayName: 'Run SonarCloud analysis'

- task: SonarCloudPublish@4
  condition: eq(variables.isFeature, true)
  displayName: 'Publish SonarCloud results'
  inputs:
    pollingTimeoutSec: '300'

- task: DotNetCoreCLI@2
  displayName: 'Publish project'
  inputs:
    command: 'publish'
    publishWebProjects: false
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory) /p:Version=$(buildVersion)'
    zipAfterPublish: false

# Create NuGet package - ONLY on feature branches
- task: DotNetCoreCLI@2
  condition: eq(variables.isFeature, true)
  displayName: 'Create NuGet Package'
  inputs:
    command: 'pack'
    packagesToPack: '**/*.csproj'
    versioningScheme: 'byEnvVar'
    versionEnvVar: 'buildVersion'
    outputDir: '$(Build.ArtifactStagingDirectory)/nuget'

# Push NuGet to Artifacts Feed - ONLY on feature branches
- task: NuGetCommand@2
  condition: eq(variables.isFeature, true)
  displayName: 'Push NuGet to Artifacts Feed'
  inputs:
    command: 'push'
    packagesToPush: '$(Build.ArtifactStagingDirectory)/nuget/*.nupkg'
    nuGetFeedType: 'internal'
    publishVstsFeed: 'HelloWorldPipeline/HelloWorldFeed'

# Tag artifact name with branch and version
- script: |
    BRANCH_NAME=$(echo "$(Build.SourceBranch)" | sed 's/refs\/heads\///g' | sed 's/\//_/g')
    ARTIFACT_NAME="${BRANCH_NAME}_$(buildVersion)"
    echo "##vso[task.setvariable variable=taggedArtifactName]$ARTIFACT_NAME"
    echo "Artifact will be named: $ARTIFACT_NAME"
    echo "Version: $(buildVersion)"
  displayName: 'Set artifact name with branch and version'

- task: PublishBuildArtifacts@1
  displayName: 'Upload tagged artifacts'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: '$(taggedArtifactName)'
    publishLocation: 'Container'

- script: |
    echo "Build completed!"
    echo "Version: $(buildVersion)"
    echo "Branch: $(Build.SourceBranchName)"
    echo "Is Feature Branch: $(isFeature)"
    echo "Artifact Name: $(taggedArtifactName)"
  displayName: 'Print final build info'
